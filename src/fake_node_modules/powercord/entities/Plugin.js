const { existsSync } = require('fs');
const { join } = require('path');
const { sleep, createElement } = require('powercord/util');
const { resolveCompiler } = require('powercord/compilers');
const Updatable = require('./Updatable');

/**
 * Main class for Powercord plugins
 * @property {Boolean} ready Whether the plugin is ready or not
 * @property {SettingsCategory} settings Plugin settings
 * @property {Object.<String, Compiler>} styles Styles the plugin loaded
 * @abstract
 */
class Plugin extends Updatable {
  constructor () {
    super(powercord.pluginManager.pluginDir);
    this.settings = powercord.api.settings.buildCategoryObject(this.entityID);
    this.ready = false;
    this.styles = {};

    /** @deprecated */
    this.registered = {
      styles: [],
      settings: [],
      commands: [],
      keybinds: [],
      routes: [],
      toasts: [],
      announcements: [],
      rpcScopes: [],
      rpcEvents: []
    };
  }

  // Getters
  get isInternal () {
    return this.entityID.startsWith('pc-');
  }

  get dependencies () {
    return this.manifest.dependencies;
  }

  get optionalDependencies () {
    return this.manifest.optionalDependencies;
  }

  get effectiveOptionalDependencies () {
    const deps = this.manifest.optionalDependencies;
    const disabled = powercord.settings.get('disabledPlugins', []);
    return deps.filter(d => powercord.pluginManager.get(d) !== void 0 && !disabled.includes(d));
  }

  get allDependencies () {
    return this.dependencies.concat(this.optionalDependencies);
  }

  get allEffectiveDependencies () {
    return this.dependencies.concat(this.effectiveOptionalDependencies);
  }

  get dependents () {
    const dependents = [ ...powercord.pluginManager.plugins.values() ].filter(p => p.manifest.dependencies.includes(this.entityID));
    return [ ...new Set(dependents.map(d => d.entityID).concat(...dependents.map(d => d.dependents))) ];
  }

  get color () {
    return '#7289da';
  }

  /**
   * Loads a plugin stylesheet. Will automatically get removed at plugin unload.
   * @param {String} path Stylesheet path. Either absolute or relative to the plugin root
   */
  loadStylesheet (path) {
    let resolvedPath = path;
    if (!existsSync(resolvedPath)) {
      // Assume it's a relative path and try resolving it
      resolvedPath = join(powercord.pluginManager.pluginDir, this.entityID, path);

      if (!existsSync(resolvedPath)) {
        throw new Error(`Cannot find "${path}"! Make sure the file exists and try again.`);
      }
    }

    const id = Math.random().toString(36).slice(2);
    const compiler = resolveCompiler(resolvedPath);
    const style = createElement('style', {
      id: `style-${this.entityID}-${id}`,
      'data-powercord': true,
      'data-plugin': true
    });

    document.head.appendChild(style);
    this.styles[id] = compiler;
    const compile = async () => {
      style.innerHTML = await compiler.compile();
    };

    compiler.enableWatcher();
    compiler.on('src-update', compile);
    this[`__compileStylesheet_${id}`] = compile;
    this[`__compiler_${id}`] = compiler;
    return compile();
  }

  // Logging
  log (...data) {
    console.log(`%c[Powercord:Plugin:${this.constructor.name}]`, `color: ${this.color}`, ...data);
  }

  debug (...data) {
    console.debug(`%c[Powercord:Plugin:${this.constructor.name}]`, `color: ${this.color}`, ...data);
  }

  warn (...data) {
    console.warn(`%c[Powercord:Plugin:${this.constructor.name}]`, `color: ${this.color}`, ...data);
  }

  error (...data) {
    console.error(`%c[Powercord:Plugin:${this.constructor.name}]`, `color: ${this.color}`, ...data);
  }

  // Update
  async _update (force = false) {
    const success = await super._update(force);
    if (success && this.ready) {
      await powercord.pluginManager.remount(this.entityID);
    }
    return success;
  }

  // Internals
  async _load () {
    try {
      while (!this.allEffectiveDependencies.every(pluginName => powercord.pluginManager.get(pluginName).ready)) {
        await sleep(1);
      }

      if (typeof this.startPlugin === 'function') {
        await this.startPlugin();
      }

      this.log('Plugin loaded');
    } catch (e) {
      this.error('An error occurred during initialization!', e);
    } finally {
      this.ready = true;
    }
  }

  async _unload () {
    try {
      this.unloadDeprecated();

      for (const id in this.styles) {
        this[`__compiler_${id}`].on('src-update', this[`__compileStylesheet_${id}`]);
        document.getElementById(`style-${this.entityID}-${id}`).remove();
        this.styles[id].disableWatcher();
      }

      if (typeof this.pluginWillUnload === 'function') {
        await this.pluginWillUnload();
      }

      this.log('Plugin unloaded');
    } catch (e) {
      this.error('An error occurred during shutting down! It\'s heavily recommended reloading Discord to ensure there are no conflicts.', e);
    } finally {
      this.ready = false;
    }
  }

  /** @deprecated */
  unloadDeprecated () {
    this.registered.styles.forEach(style => powercord.styleManager.unmount(style));
    this.registered.settings.forEach(tab => powercord.api.settings.unregisterSettings(tab));
    this.registered.commands.forEach(command => powercord.api.commands.unregisterCommand(command));
    this.registered.keybinds.forEach(keybind => powercord.api.keybinds.unregisterKeybind(keybind));
    this.registered.routes.forEach(path => powercord.api.router.unregisterRoute(path));
    this.registered.toasts.forEach(toast => powercord.api.notices.closeToast(toast));
    this.registered.announcements.forEach(announcement => powercord.api.notices.closeAnnouncement(announcement));
    this.registered.rpcScopes.forEach(scope => powercord.api.rpc.unregisterScope(scope));
    this.registered.rpcEvents.forEach(evt => powercord.api.rpc.unregisterEvent(evt));
  }

  /** @deprecated */
  registerSettings (section, displayName, render) {
    this._deprecationWarning('registerSettings');
    this.registered.settings.push(section);
    powercord.api.settings.registerSettings(section, {
      category: this.entityID,
      label: displayName,
      render
    });
  }

  /** @deprecated */
  registerCommand (command, aliases, description, usage, func, autocompleteFunc) {
    this._deprecationWarning('registerCommand');
    this.registered.commands.push(command);
    powercord.api.commands.registerCommand({
      command,
      aliases,
      description,
      usage,
      executor: func,
      autocomplete: autocompleteFunc
    });
  }

  /** @deprecated */
  registerKeybind (id, name, description, func, keybind, global = false) {
    this._deprecationWarning('registerKeybind');
    this.registered.keybinds.push(id);
    powercord.api.keybinds.registerKeybind(id, {
      keybind,
      executor: func,
      isGlobal: global
    });
  }

  /** @deprecated */
  updateKeybind (id, keybind) {
    this._deprecationWarning('updateKeybind');
    this.registered.keybinds.push(id);
    powercord.api.keybinds.updateKeybind(id, keybind);
  }

  /** @deprecated */
  registerRoute (path, render, noSidebar = false) {
    this._deprecationWarning('registerRoute');
    this.registered.routes.push(path);
    powercord.api.router.registerRoute(path, render, noSidebar);
  }

  /** @deprecated */
  sendToast (id, props) {
    this._deprecationWarning('sendToast');
    this.registered.toasts.push(id);
    powercord.api.notices.sendToast(id, props);
  }

  /** @deprecated */
  closeToast (id) {
    this._deprecationWarning('closeToast');
    this.registered.toasts = this.registered.toasts.filter(t => t !== id);
    powercord.api.notices.closeToast(id);
  }

  /** @deprecated */
  sendAnnouncement (id, props) {
    this._deprecationWarning('sendAnnouncement');
    this.registered.announcements.push(id);
    powercord.api.notices.sendAnnouncement(id, props);
  }

  /** @deprecated */
  closeAnnouncement (id) {
    this._deprecationWarning('closeAnnouncement');
    this.registered.announcements = this.registered.announcements.filter(t => t !== id);
    powercord.api.notices.closeAnnouncement(id);
  }

  /** @deprecated */
  registerRPCScope (scope, grant) {
    this._deprecationWarning('registerRPCScope');
    this.registered.rpcScopes.push(scope);
    powercord.api.rpc.registerScope(scope, grant);
  }

  /** @deprecated */
  unregisterRPCScope (scope) {
    this._deprecationWarning('unregisterRPCScope');
    this.registered.rpcScopes = this.registered.rpcScopes.filter(s => s !== scope);
    powercord.api.rpc.unregisterScope(scope);
  }

  /** @deprecated */
  registerRPCEvent (event, handler) {
    this._deprecationWarning('registerRPCEvent');
    this.registered.rpcEvents.push(event);
    powercord.api.rpc.registerEvent(event, handler);
  }

  /** @deprecated */
  unregisterRPCEvent (event) {
    this._deprecationWarning('unregisterRPCEvent');
    this.registered.rpcEvents = this.registered.rpcEvents.filter(e => e !== event);
    powercord.api.rpc.unregisterEvent(event);
  }

  /** @deprecated */
  loadCSS (id, path) {
    this._deprecationWarning('loadCSS');
    if (path === void 0) {
      path = id;
    }

    return this.loadStylesheet(path);
  }

  /** @private */
  _deprecationWarning (method) {
    // @todo: Migration guides
    console.group(`%c[${this.constructor.name}] DEPRECATION WARNING`, 'color: #f04747');
    console.warn(`${method} is deprecated and should no longer be used`);
    console.warn('It\'ll be pernamently removed from Powercord on %cNovember 1st, 2020', 'font-weight: bold');
    console.warn('Please refer to the migration guide to update your plugin: https://github.com/powercord-org/powercord/wiki/May-2020-Migration-Guide');
    console.groupEnd();
  }
}

module.exports = Plugin;
